*
  NAM  UTILIO
  TTL  UTILITIES FOR IN/OUTPUT
*
*    DEFINE EXTERNAL REFERENCES
*
  XDEF	PWRTEN,LOG10X,ONE
*
  XREF	LNORM,FPMOVE,FMUL,DNORM1,SNORM,CLRES
  XREF	TFRACT,COMP2
*
*    REVISION HISTORY:
*    DATE	  PROGRAMMER		  REASON
*
*   23.MAY.80	  G.WALKER & G.STEVENS	  ORIGINAL
*   05.JUN.80	  G. STEVENS		  FIX LOG2X
*   11.JUN.80	  G. STEVENS		  FIX PWR TO ACCEPT "0"
*					  AS AN ARGUMENT.
*   14.JUL.80	  G. STEVENS		  CODE COMPACTION IN LOG2X
*   17.JUL.80	  G. WALKER		  CODE SHRINK (XDEF ONE)
*   29.JUL.80	  G. WALKER		  PWR CLEARS RESULT FOR FMUL
*   31.JUL.80	  G. STEVENS		  FIX LOG2X FOR ZERO FRACTION
*   03.AUG.80	  G. STEVENS		  FIX SIDE EFFECTS IN LOG10X
*   27.OCT.80	  G. STEVENS		  FIX LOG2X SO X-REG. IS SAVED
*   28.OCT.80	  G. STEVENS		  CHANGE LOG10(2) CONSTANT
*   15.DEC.80	  G.WALKER		  CLEAR STIKY IN PWRMUL
*
  PAG
**********************************************************
*
*	 BELOW IS A TABLE CONTAINING FLOATING POINT POWERS
*    OF 10^N FOR N= 1 - 27,54,108,216.	IF THIS TABLE IS
*    TOO LARGE, THE POWERS OF 1 - 27 CAN BE REPLACED BY
*    A MULTIPLY-BY-TEN LOOP.{
*
FPNUM MACR
  FCB  $\0,$\1,$\2,$\3,$\4,$\5,$\6,$\7,$\8,$\9,$\A,$\B,$\C
  ENDM
*
TEN216 FPNUM  0,02,CD,B9,A7,4A,06,37,CE,2E,E1,00,00
TEN108 FPNUM  0,01,66,DA,01,EE,64,1A,70,8D,EA,00,00
TEN54  FPNUM  0,00,B3,A7,0C,3C,40,A6,4E,6C,52,00,00
TENTAB FPNUM  0,00,03,A0,00,00,00,00,00,00,00,00,00
       FPNUM  0,00,06,C8,00,00,00,00,00,00,00,00,00
       FPNUM  0,00,09,FA,00,00,00,00,00,00,00,00,00
       FPNUM  0,00,0D,9C,40,00,00,00,00,00,00,00,00
       FPNUM  0,00,10,C3,50,00,00,00,00,00,00,00,00
       FPNUM  0,00,13,F4,24,00,00,00,00,00,00,00,00
       FPNUM  0,00,17,98,96,80,00,00,00,00,00,00,00
       FPNUM  0,00,1A,BE,BC,20,00,00,00,00,00,00,00
       FPNUM  0,00,1D,EE,6B,28,00,00,00,00,00,00,00
       FPNUM  0,00,21,95,02,F9,00,00,00,00,00,00,00
       FPNUM  0,00,24,BA,43,B7,40,00,00,00,00,00,00
       FPNUM  0,00,27,E8,D4,A5,10,00,00,00,00,00,00
       FPNUM  0,00,2B,91,84,E7,2A,00,00,00,00,00,00
       FPNUM  0,00,2E,B5,E6,20,F4,80,00,00,00,00,00
       FPNUM  0,00,31,E3,5F,A9,31,A0,00,00,00,00,00
       FPNUM  0,00,35,8E,1B,C9,BF,04,00,00,00,00,00
       FPNUM  0,00,38,B1,A2,BC,2E,C5,00,00,00,00,00
       FPNUM  0,00,3B,DE,0B,6B,3A,76,40,00,00,00,00
       FPNUM  0,00,3F,8A,C7,23,04,89,E8,00,00,00,00
       FPNUM  0,00,42,AD,78,EB,C5,AC,62,00,00,00,00
       FPNUM  0,00,45,D8,D7,26,B7,17,7A,80,00,00,00
       FPNUM  0,00,49,87,86,78,32,6E,AC,90,00,00,00
       FPNUM  0,00,4C,A9,68,16,3F,0A,57,B4,00,00,00
       FPNUM  0,00,4F,D3,C2,1B,CE,CC,ED,A1,00,00,00
       FPNUM  0,00,53,84,59,51,61,40,14,84,A0,00,00
       FPNUM  0,00,56,A5,6F,A5,B9,90,19,A5,C8,00,00
TEN27  FPNUM  0,00,59,CE,CB,8F,27,F4,20,0F,3A,00,00
  PAG
**************************************************
*
*    PWRTEN --
*	 LEAVES AT 'RESULT,U' THE POWER OF TEN
*    SPECIFIED AS A POSITIVE INTEGER IN DREG.
*    PWRTEN USES THE GENERAL 'FMUL' ROUTINE, AND
*    THUS BASHES  ARG1,ARG2, AND RESULT ON THE
*    STACK FRAME.
*
*    ON ENTRY:
*	 D = POSITIVE INTEGER POWER OF TEN (1<=D<=512)
*	 OTHER REGS DON'T CARE.
*    ON EXIT:
*	 ALL REGISTERS ARE UNCHANGED.
*	 RESULT,U = FLOATING-POINT POWER OF TEN
*	 ARG1 AND ARG2 DESTROYED.
*
*    LOCAL STORAGE:
*	 INITN -- 0=RESULT NOT INIT.; 1=IS INIT.
*
INITN SET 0
*
ALL    REG    D,CC,X,Y,U
ALLPC  REG    D,CC,X,Y,U,PC
*
PWRTEN EQU *
  PSHS #ALL
  LEAS -1,S
  CLR  INITN,S
  IF  D,EQ,#0		      IF POWER IS ZERO
    LEAX  ONE,PCR		 RETURN 10^0 = ONE
    LEAY  RESULT,U
    LBSR  FPMOVE	      MOVE ONE TO THE RESULT
*
  ELSE
    WHILE   D,GE,#216		WHILE POWER IS 216 OR MORE
      LEAX TEN216,PCR		MULTIPLY IN 10^216
      SUBD #216
      BSR PWRMUL
    ENDWH
    IF	D,GE,#108		IF POWER IS 108 OR MORE
      LEAX  TEN108,PCR		    MULTIPLY IN 10^108
      SUBD  #108
      BSR  PWRMUL
    ENDIF
    IF	D,GE,#54	     IF POWER IS 54 OR MORE
      LEAX  TEN54,PCR		 MULTIPLY IN 10^54
      SUBD  #54
      BSR  PWRMUL
    ENDIF
    IF	D,GE,#27	     IF POWER IS 27 OR MORE
      LEAX  TEN27,PCR		MULTIPLY IN 10^27
      SUBD  #27
      BSR  PWRMUL
    ENDIF
    IF	D,GT,#0 	   IF POWER IS STILL NON-ZERO
      DECB		    CALCULATE ADDRESS OF TABLE
      LDA  #13		       POWER OF TEN
      MUL
      LEAX  TENTAB,PCR
      LEAX  D,X
      BSR  PWRMUL	      MULTIPLY IN VALUE FROM TABLE
    ENDIF
*
  ENDIF
  LEAS 1,S
  PULS #ALLPC
*
*****************************************************
*
*    PWRMUL --
*	 USED BY 'PWRTEN' TO MULTIPLY THE RESULT BY
*    EACH NEW POWER OF TEN.  IF THE RESULT IS NOT
*    INITIALIZED,  THEN THE APPROPRIATE POWER OF TEN
*    IS MOVED FROM THE TABLE TO THE RESULT,  ELSE
*    THE RESULT IS MULTIPLIED BY THE APPORPRIATE TABLE
*    ENTRY.
*
*    ON ENTRY:
*	 X = APPROPRIATE POWER OF TEN IN TABLE
*	 OTHER REGS DON'T CARE.
*
*    ON EXIT:
*	 D,U,S ARE UNCHANGED.
*	 OTHER REGS ARE BASHED.
*
PWRMUL EQU *
  IFTST  (INITN+2,S),EQ,#0    IF RESULT IS NOT INITIALIZED
    LEAY RESULT,U		 MOVE TABLE VALUE TO RESULT
    LBSR FPMOVE
    COM  INITN+2,S		 SHOW RESULT AS INITIALIZED
  ELSE
    LEAY  ARG1,U	      ELSE MULTIPLY RESULT BY TABLE
    LBSR  FPMOVE		  VALUE
    LEAX  RESULT,U
    LEAY  ARG2,U
    LBSR  FPMOVE
    PSHS  D
    LDB  #CLRFRC		CLEAR RESULT FRACTION
    LBSR CLRES
    CLR  STIKY,U		ZERO STICKY BYTE INTO FMUL
    LBSR  FMUL			MULTILPY POWERS OF TEN
    PULS  D
  ENDIF
*
  RTS
*
*
* HERE IS A FLOATING ONE CONSTANT. NOTE THIS CONSTANT EXISTS
*   IN 'OUTS.SA' AND PERHAPS OTHER MODULES AS WELL.
*   IT IS 'XDEF'ED HERE AND SHOULD BE XREF'ED IN
*   THE OTHER MODULES TO AVOID DUPLICATE CODE.
*
ONE FCB  00,00,00,$80,00,00
    FCB  00,00,00,00,00,00
    FCB  TYNORM
*
  PAG
*******************************************************
*
*    HERE IS THE FUNCTION LOG 10 (X) WHICH IS
* USED WITH THE INS AND OUT ROUTINES TO THE
* FLOATING PT. PACKAGE.
*
*
* PROCEDURE  LOG2X
*
*    LOG2X CHANGES A FLOATING OPERAND, F , TO ITS
* LOGARITHM TO THE BASE 2 BY THE METHOD IN YOUNG AND
* GREGORY, A SURVEY OF NUMERICAL MATHEMATICS,VOL. 1,
* PP. 64-65
*
*  ON ENTRY: X - POINTS TO THE OPERAND IN THE STACK FRAME
*
*  ON EXIT: X - POINTS TO THE LOG2X OF THE INPUT OPERAND
*	    ON THE STACK FRAME.
*
*
SINBND EQU  05
DBLBND EQU  07
*
*
LOG2X EQU  *
*
 PSHS  X,Y,D	     SAVE CALLER'S REGISTERS
*
 LDB  RPREC,U	      GET PRECISION INDEX
*
* SHIFT FRACTION TO THE LEFT ONCE TO YIELD FRACTIONAL
* PART
*
 ANDCC	#NC	   CLEAR CARRY
 LSHIFT  FRACT,X,7
*
* NOW SET THE SIGN OF THE LOG2X RESULT TO THE SIGN
* OF THE EXPONENT SINCE THE EXPONENT IS ALMOST THE
* CORRECT VALUE ALREADY
*
 LDA EXP,X
 ANDA #BIT7	     SIGN BIT
 STA  SIGN,X
*
* CONVERT EXPONENT FROM  BINARY INTEGER TO A SIGN
* AND MAGNITUDE FLOATING INTEGER
*
 IFCC  LT	     EXPONENT NEGATIVE
*
* TAKE 2'S COMPLEMENT OF THE EXPONENT
*
   COM	EXP,X
   COM	EXP+1,X
*
* SINCE EXPONENT IS NEGATIVE, SET UP A 2'S COMPLEMENT
* ADD BETWEEN THE EXPONENT AND THE FRACTIONAL PART OF
* THE SIGNIFICAND. I.E. -E.0 + 0.FFF = -(E.0 - 1 +
* (1 - 0.FFF)) UNLESS THE FRACTION IS ZERO IN WHICH
* CASE NOTHING IS DONE.
*
* CHECK FOR FRACTION = ZERO
*
   LBSR  TFRACT
   IFCC  EQ		 FRACTION = ZERO
     LDD  EXP,X 	 CORRECT FCOMPLEMENT
     ADDD  #01
     STD  EXP,X
*
*
* CALCULATE (1 - 0.FFF) WHICH IS REALLY THE 2'S COMP.
* OF (0.FFF)
*
   ELSE
     LEAX  FRACT,X
     LDB  #COMPSZ	 NO OF BYTES
     LBSR  COMP2
     LEAX  -FRACT,X	  RESTORE X-REG
*
   ENDIF	     FRACTION = ZERO
*
 ENDIF		     EXPONENT NEGATIVE
*
* COMBINE THE EXPONENT AND FRACTION INTO ONE FLOATING
* VALUE I.E. JUST SHIFT THE EXPONENT INTO THE SIGNIFICAND
* AND SET THE CORRECT RESULTING EXPONENT.
*
 LDB  RPREC,U	     PRECISION INDEX
 IF  B,EQ,#SIN	     SINGLE PRECISION
   LEAY  SINBND,X    BYTE BOUNDARY SINGLE PREC.
*
 ELSE		     DOUBLE PRECISION
   LEAY  DBLBND,X    BYTE BOUNDARY DOUBLE PREC.
*
   LDA	DBLBND+2,X   LSBYTE FRACTION
   STA	DBLBND+4,X
*
 ENDIF		     SINGLE PRECISION
*
* MOVE REST OF SIGNIFICAND OVER 2 BYTES
*
 PSHS  X
 WHILE	Y,GE,(,S++)
   MOVD  (0,Y),(2,Y)
   LEAY  -2,Y
   PSHS  X
*
 ENDWH
*
* SET CORRECT EXPONENT I.E. EXPSIZ -1 = 15
*
 LDD  #EXPSIZ-1
 STD  EXP,X
*
* NOW NORMALIZE THE RESULTING FLOATING VALUE
*
 LBSR  LNORM
*
 PULS  X,Y,D,PC 	  RESTORE AND RETURN
 PAG
******************************************************
*
* PROCEDURE LOG10X
*
*    LOG10X COMPUTES THE LOG TO THE BASE 10 OF
* A FLOATING OPERAND, F. THE LOG10(X) IS CALC-
* ULATED AS DESCRIBED IN THE "SPECIFICATION"
* BY JEROME COONEN BY USING THE RELATION:
*
*   LOG10(X) = LOG2(X) * LOG10(2)
*
* ON ENTRY: X - POINTS TO THE ARGUMENT ON THE
*	    STACK FRAME.
*
* ON EXIT: RESULT,U CONTAINS LOG10(X) OF THE
*	  INPUT ARGUMENT
*
* LOCAL EQUATE
COMPSZ EQU  08
*
LOG10X EQU  *
*
 PSHS  X,Y,D		   SAVE CALLERS REGS.
*
 BSR  LOG2X		  FIND LOG2(X)
*
* CHECK FOR A ZERO RESULT FROM LOG2(X), IF SO THEN
* THEN RETURN A ZERO AND TERMINATE CALCULATIONS.
*
 LBSR  TFRACT		  TEST FOR ZERO
 IFCC  EQ
   LDD	#$8000
   STD	EXP,X		  SET ZERO EXPONENT
   CLR	SIGN,X		  MAKE RESULT POSITIVE
   LDA	#TYZERO
   STA	TYPE,X		  SET TYPE FOR ZERO
*
* ELSE CONTINUE AS PLANNED
*
 ELSE L
*
* TEMPORARILY PERFORM ALL CALCULATIONS IN EXTENDED
*
   LDA	RPREC,U 	     PRECISION INDEX
   PSHS  A		     SAVE IT
   LDA	#EXT		     EXTENDED PRECISION INDEX
   STA	RPREC,U 	     REPLACE INDEX
*
* NOW FIND OUT WHERE TO PUT THE LOG10(2) CONSTANT;
* THIS DEPENDS ON WHERE LOG2(X) IS. NEXT MOVE THE
* CONSTANT INTO THE STACK FRAME.
*
   LEAY  ARG1,U 	    TRY ARG1
   PSHS  Y
   IF  X,EQ,(,S++)	    IF ALREADY TAKEN
     LEAY  ARG2,U	    USE ARG2
*
   ENDIF
*
*
   LEAX  LOG102,PCR	    LOG10(2) CONSTANT
   LBSR  FPMOVE 	      BRING IT IN
*
* TEMPORARILY CHANGE THE ROUND MODE TO NEAREST;
* FCMULT ROUNDS ITS RESULT AT THE END OF THE OPERATION
*
   LDA	[PFPCB,U]	    PRESENT CTRL. BYTE
   PSHS  A		    SAVE IT
*
   ANDA  #$FF-(BIT1+BIT2)   REMOVE RND. MODE
   ORA	#RN		    REPLACE WITH NEAREST
   STA	[PFPCB,U]	    REPLACE CTRL. BYTE
*
* PERFORM MULTIPLICATION: LOG2(X) * LOG10(2)
*  = LOG10(X)
*
   LEAX  RESULT,U	    ZERO OUT RESULT
   LDB	#CLRALL
   LBSR  CLRES
*
   LBSR  FMUL
*
* RESTORE OID ROUNDING MODE IN THE CONTROL BYTE OF
* THE FPCB
*
   PULS  D		    OLD CTRL. BYTE
   STA	[PFPCB,U]	    RESTORE IT
*
* RESTORE PPREC PRECISION INDEX
*
   STB	RPREC,U 	     REPLACE IT
*
* FINALLY MOVE	LOG10X	BACK TO THE LOCATION
* OF THE ORIGINAL INPUT ARGUMENT.
*
   LEAX  RESULT,U	       SOURCE
   LDY	2,S		       POINTER TO ORIGINAL ARGUMENT
   LBSR  FPMOVE 	       MOVE IT!
*
*
 ENDIF			     LOG2X EQUALS ZERO
*
 PULS  X,Y,D,PC 	  RESTORE AND RETURN
*
*
* HERE IS THE LOG10(2) CONSTANT
*
LOG102 FCB  00,$FF,$FE,$9A,$20,$9A
       FCB  $84,$FB,$CF,$F7,$99,00
       FCB  TYNORM
*
