*
 NAM CHECK
 TTL ROUTINES TO CHECK SPECIAL CASES AND INVALID OPS.
*
* LINKING LOADER DEFINTIONS
*
  XDEF	CKINVD,CHKZER,CHKINF,DIVZER
*
  XREF	RTAR1,IOPSUB,RTINF,ISDNRM
*
* REVISION HISTORY:
*   DATE	PROGRAMMER     REASON
*
*  23.MAY.80	G. STEVENS     ORIGINAL
*  28.MAY.80	G. STEVENS     REWRITE CKINVD
*  03.JUNE.80	G. STEVENS     MAKE CKINVD HANDLE NAN,ZEROS
*			       AND INFINITIES CORRECTLY
*  21.AUG.80	G. STEVENS     REMOVE IOP 17 FROM DIVZER
*
 PAGE
*
*  HERE ARE SOME OF THE COMPONENT ROUTINES
* FOR THE FP09. THEY INCLUDE CHKZER, CHECK
* ZERO AGAINST THE ROUNDING MODES; CHECK
* CHECK INFINITY AGAINST A/P MODES OF
* CLOSURE; DIVZER, HANDLES DIVISION BY ZERO;
* RTNAN, BUILD UP A "NAN" WITH PROPER
* NAN ADDRES INSERTED.
*
***************************************************************
*
*  PROCEDURE CHKZER
*
*  THIS ROUTINE CHECKS ZERO AGAINST ROUNDING
* MODES IN A FLP ADDITION WHEN BOTH OPERANDS
* ARE ZERO IN ORDER TO RETURN A ZERO RESULT
* OF THE CORRECT SIGN. IF SIGNS ARE THE SAME
* A ZERO OF THAT SIGN IS RETURNED. IF THE
* SIGN ARE OPPOSITE THEN +0 IS RETURNED
* IN ROUDING MODES RN,RZ,RP AND -O IS
* RETURNED IN ROUNDING MODE RM.
*
* RETURN A ZERO TO RESULT
*
CHKZER LBSR RTAR1
*
* NOW CHECK TO SEE IF THE SIGN NEEDS
* MODIFYING.
*
 LDA  ARG1,U
 EORA  ARG2,U
*
* IF THE SIGNS ARE NOT EQUAL, CHECK THE ROUNDING
* MODE TO DETERMINE THE PROPER SIGN.
*
 IFCC LT
   LDA	[PFPCB,U]
   ANDA  #CTLRND  GET ROUNDING MODE INFO.
   IF A,GE,#BIT1+BIT2  RM MODE
     LDA  #BIT7
     STA  RESULT,U  RETURN -0
*
   ELSE
     CLR  RESULT,U  RETURN +0
   ENDIF
 ENDIF
*
 RTS  RETURN
*
 PAG
*******************************************************************
*
*  PROCEDURE  CHKINF
*
*   THIS ROUTINE CHECKS INFINITY AGAINST
* CLOSURE MODES IN A FLP ADDITION WHEN
* BOTH OPERANDS ARE INFINITY TO DETERMINE
* WHETHER TO RETURN INFINITY OR A NAN
* WITH PROPER INVALID OPERATION CODE
*
*
* CHECK FOR A/P MODES
*
CHKINF	LDA  [PFPCB,U]
 ANDA  #BIT0
 IFCC GT   AFFINE MODE
   LDA	ARG1,U
   EORA  ARG2,U
*
* IF SIGNS THE SAME RETURN INFINITY
* OF THAT SIGN.
*
   IFCC GE
     LBSR  RTAR1
*
* IF SIGNS DIFFER RETURN "NAN" AND
* SET IOP = 2
*
   ELSE
     IOP 2  (+INF)+(-INF); AFFINE MODE
   ENDIF
*
* ELSE IN THE PROTECTIVE MODE RETURN NAN
* AND SET IOP = 8
*
 ELSE
   IOP	8  +/-	INF; PROTECTIVE MODE
 ENDIF
*
 RTS  RETURN
*
 PAG
***************************************************************
*
* PROCEDURE  DIVZER
*
*  THIS ROUTINE HANDLES THE CASE OF DIVISION
* BY ZERO.
*
* ON ENTRY: ARG2 CONTAINS A TRUE ZERO
*	    U - STACK FRAME POINTER
*
* ON EXIT: RESULT CONTAINS AN INFINITY W/
*	   SIGN OF THE INPUT ARGUMENT.
*	   U, S - UNCHANGED
*	   X,Y,D,CC - DESTROYED
*
* OPERATION: THE DIVISION BY ZERO FLAG IN TSTAT IS SET
* AND AN INFINITY OF THE SIGN OF THE INPUT ARGUMENT IS
* RETURNED IN THE STACK FRAME RESULT.
*
*
* CHECK DIVISION BY ZERO TRAP ENABLE
*
DIVZER EQU  *
*
   BSETA  BIT3,(TSTAT,U)
   LBSR  RTINF
*
 RTS   RETURN
*
 PAG
******************************************************************
*
* PROCEDURE  CKINVD
*
*     CKINVD CHECKS FOR AN INVALID RESULT OF AN ARITHMETIC
* OPERATION. IF THE RESULTIS UNORMALIZED AND THE DESTINATION
* IS SINGLE OR DOUBLE THEN SIGNAL IOP. = 16 AND RETURN A
* NON TRAPPING NAN.
*
*
CKINVD EQU  *
*
* CHECK FOR ZERO OR NAN OR INFINITY
*
 LDD  EXPR,U
 IF  D,NE,#INFEX
   IF  D,NE,#ZEROEX
*
* CHECK THE PRECISION OF THE RESULT
*
     LDA  RPREC,U
     IF  A,LE,#DBL	   SINGLE OR DOUBLE
       LBSR  ISDNRM	   CHECK FOR DENORMALZED
       IFCC  EQ 	   RESULT IS DENORMALIZD
	 LDD  EXPR,U	   SUBTRACT BIAS FROM EXPONENT
	 SUBD  #01
	 STD  EXPR,U
*
       ELSE
	 LDA  FRACTR,U
	 IFCC  GE	   NOT NORMALIZED
	   IOP	16	   SIGNAL INVALID OPERATION
*
	 ENDIF		   NOT NORMALIZED
*
       ENDIF		   IS DENORMALIZED
*
     ENDIF		   SINGLE OR DOUBLE
*
   ENDIF		   NOT A ZERO
*
 ENDIF			   NOT A NAN OR INFINITY
*
*
 RTS		       RETURN
*
*
